// Copyright (C) 2015 ent (entdark)
//
// cl_demos_auto.cpp - autorecording demos routine
//
// credits: 
// - teh aka dumbledore aka teh_1337: autorecording demos
// - sil: saving LastDemo
// - CaNaBiS: formatting with %

#include "client.h"

cvar_t	*cl_autoDemo;
cvar_t	*cl_autoDemoFormat;

#define MAX_TIMESTAMPS 256
#define DEFAULT_NAME "LastDemo/LastDemo_recording"
#define DEFAULT_NAME_LAST "LastDemo/LastDemo"

static struct demoAuto_s {
	// reset on demoAutoRecord()
	char				demoName[MAX_OSPATH];
	char				customName[MAX_QPATH];
	int					timeStamps[MAX_TIMESTAMPS];
	// reset on demoAutoInit()
	char				ext[7];	// ".dm_16"
} demoAuto;

char *demoAutoFormat(const char* name) {	
	const	char *format;
	qboolean haveTag = qfalse;
	static char	outBuf[512];
	int			outIndex = 0;
	int			outLeft = sizeof(outBuf) - 1;
	
	int t = 0;
	char timeStamps[MAX_QPATH] = "";
	qtime_t ct;

	char playerName[MAX_QPATH], *mapName = COM_SkipPath(Info_ValueForKey((cl.gameState.stringData + cl.gameState.stringOffsets[CS_SERVERINFO]), "mapname"));
	Q_strncpyz(playerName, Info_ValueForKey((cl.gameState.stringData + cl.gameState.stringOffsets[CS_PLAYERS+cl.snap.ps.clientNum]), "n"), sizeof(playerName));
	Q_CleanStr(playerName, qtrue);
	Com_RealTime(&ct);
	
	format = cl_autoDemoFormat->string;
	if (!format || !format[0]) {
		if (!name || !name[0]) {
			format = "%t";
		} else {
			format = "%n_%t";
		}
	}

	while (*format && outLeft  > 0) {
		if (haveTag) {
			char ch = *format++;
			haveTag = qfalse;
			switch (ch) {
			case 'd':		//date
				Com_sprintf( outBuf + outIndex, outLeft, "%d-%02d-%02d-%02d%02d%02d",
								1900+ct.tm_year, ct.tm_mon+1,ct.tm_mday,
								ct.tm_hour, ct.tm_min, ct.tm_sec);
				outIndex += strlen( outBuf + outIndex );
				break;
			case 'm':		//map
				Com_sprintf( outBuf + outIndex, outLeft, "%s", mapName);
				outIndex += strlen( outBuf + outIndex );
				break;
			case 'n':		//custom demo name
				Com_sprintf( outBuf + outIndex, outLeft, "%s", name);
				outIndex += strlen( outBuf + outIndex );
				break;
			case 'p':		//current player name
				Com_sprintf( outBuf + outIndex, outLeft, "%s", playerName);
				outIndex += strlen( outBuf + outIndex );
				break;
			case 't':		//timestamp
				while (demoAuto.timeStamps[t] && t < MAX_TIMESTAMPS) {
					int min = demoAuto.timeStamps[t] / 60000;
					int sec = (demoAuto.timeStamps[t] / 1000) % 60;
					if (t == 0) {
						Q_strcat(timeStamps, sizeof(timeStamps), va("%02d%02d", min, sec));
					} else {
						Q_strcat(timeStamps, sizeof(timeStamps), va("_%02d%02d", min, sec));
					}
					t++;
				}
				Com_sprintf( outBuf + outIndex, outLeft, "%s", timeStamps);
				outIndex += strlen( outBuf + outIndex );
				break;
			case '%':
				outBuf[outIndex++] = '%';
				break;
			default:
				continue;
			}
			outLeft = sizeof(outBuf) - outIndex - 1;
			continue;
		}
		if (*format == '%') {
			haveTag = qtrue;
			format++;
			continue;
		}
		outBuf[outIndex++] = *format++;
		outLeft = sizeof(outBuf) - outIndex - 1;
	}
	outBuf[ outIndex ] = 0;
	return outBuf;
}

// Standard naming for screenshots/demos
static char *demoAutoGenerateDefaultFilename(void) {
	qtime_t ct;
	const char *pszServerInfo = cl.gameState.stringData + cl.gameState.stringOffsets[CS_SERVERINFO];
	
	Com_RealTime(&ct);
	return va("%d-%02d-%02d-%02d%02d%02d-%s",
								1900+ct.tm_year, ct.tm_mon+1,ct.tm_mday,
								ct.tm_hour, ct.tm_min, ct.tm_sec,
								COM_SkipPath(Info_ValueForKey(pszServerInfo, "mapname")));
}

void demoAutoSave_f(void) {
	int t = 0;

	if (cls.state != CA_ACTIVE) {
		Com_Printf ("You must be in a level to save the demo.\n");
		return;
	}

	if (strstr(cl_autoDemoFormat->string, "%t"))
		while (demoAuto.timeStamps[t] && t < MAX_TIMESTAMPS - 1)
			t++;
	demoAuto.timeStamps[t] = cl.serverTime - atoi(cl.gameState.stringData + cl.gameState.stringOffsets[CS_LEVEL_START_TIME]);

	if (!(Cmd_Argc() < 2)) {
		Q_strncpyz(demoAuto.customName, Cmd_Argv( 1 ), sizeof(demoAuto.customName));
	}
	Com_sprintf(demoAuto.demoName, sizeof(demoAuto.demoName), "%s", demoAutoFormat(demoAuto.customName));
	if (demoAuto.demoName[0]) {
		Com_Printf(S_COLOR_WHITE "Demo will be saved into " S_COLOR_GREEN "%s%s\n", demoAuto.demoName, demoAuto.ext);
	} else {
		Com_Printf(S_COLOR_YELLOW "WARNING: Demo will not be saved because name is empty. Check cl_autoDemoFormat cvar\n");
	}
}

qboolean demoFindFreePath(char *path, int size, const char *name) {
	int		i;

	Com_sprintf(path, size, "demos/%s", name);
	COM_SanitizeExtension(path, size, demoAuto.ext);

	for (i = 1; i < 1000 && FS_FileExists(path); i++) {
		Com_sprintf(path, size, "demos/%s (%d)", name, i);
		COM_SanitizeExtension(path, size, demoAuto.ext);
	}

	if (i == 1000) {
		return qfalse;
	}

	return qtrue;
}

void demoAutoSaveLast_f(void) {
	char	lastDemoPath[MAX_QPATH];
	char	autoDemoPath[MAX_QPATH];
	const char *autoDemoName;

	if (Cmd_Argc() < 2) {
		autoDemoName = demoAutoGenerateDefaultFilename();
	} else {
		autoDemoName = Cmd_Argv(1);
	}

	Com_sprintf(lastDemoPath, sizeof(lastDemoPath), "demos/%s", DEFAULT_NAME_LAST);
	COM_SanitizeExtension(lastDemoPath, sizeof(lastDemoPath), demoAuto.ext);
	Com_sprintf(autoDemoPath, sizeof(autoDemoPath), "demos/%s", autoDemoName);
	COM_SanitizeExtension(autoDemoPath, sizeof(autoDemoPath), demoAuto.ext);

	if (!demoFindFreePath(autoDemoPath, sizeof(autoDemoPath), autoDemoName)) {
		Com_Printf(S_COLOR_RED "Could not find free demo name: %s\n", autoDemoPath);
		return;
	}

	if (!FS_FileExists(lastDemoPath)) {
		Com_Printf("LastDemo has been saved already\n");
		return;
	}

	if (!FS_Rename(lastDemoPath, autoDemoPath)) {
		Com_Printf(S_COLOR_RED "LastDemo has failed to save into %s\n", autoDemoPath);
		return;
	}

	Com_Printf(S_COLOR_GREEN "LastDemo successfully saved into %s\n", autoDemoPath);
}

extern void CL_StopRecord_f( void );
void demoAutoComplete(void) {
	char	currDemoPath[MAX_QPATH];
	char	lastDemoPath[MAX_QPATH];

	CL_StopRecord_f();

	Com_sprintf(currDemoPath, sizeof(currDemoPath), "demos/%s%s", DEFAULT_NAME, demoAuto.ext);

	if (demoAuto.demoName[0]) {
		if (!demoFindFreePath(lastDemoPath, sizeof(lastDemoPath), demoAuto.demoName)) {
			Com_Printf(S_COLOR_RED "Could not find free demo name: %s\n", lastDemoPath);
			return;
		}
	} else {
		Com_sprintf(lastDemoPath, sizeof(lastDemoPath), "demos/%s", DEFAULT_NAME_LAST);
		COM_SanitizeExtension(lastDemoPath, sizeof(lastDemoPath), demoAuto.ext);
	}

	if (!FS_Rename(currDemoPath, lastDemoPath)) {
		Com_Printf(S_COLOR_RED "Demo has failed to save\n");
	} else if (!demoAuto.demoName[0]) {
		Com_Printf(S_COLOR_GREEN "Demo temporarily saved into %s\n", lastDemoPath);
	} else {
		Com_Printf(S_COLOR_GREEN "Demo successfully saved into %s\n", lastDemoPath);
	}
}

// Dynamically names a demo and sets up the recording
void demoAutoRecord(void) {
	//mod resetting allowed in init only
	Com_Memset(&demoAuto, 0, offsetof(struct demoAuto_s, ext));
	Cbuf_AddText(va("record %s\n", DEFAULT_NAME));
}

void demoAutoInit(void) {
	memset(&demoAuto, 0, sizeof(demoAuto));
	Com_sprintf(demoAuto.ext, sizeof(demoAuto.ext), ".dm_%d", MV_GetCurrentProtocol());
}
